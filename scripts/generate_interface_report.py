"""Generate docs/INTERFACE.md from the stable public API contract."""

from __future__ import annotations

import inspect
from pathlib import Path

import openatoms.api as public_api

ROOT = Path(__file__).resolve().parents[1]
OUTPUT = ROOT / "docs" / "INTERFACE.md"


def _format_signature(name: str) -> str:
    obj = getattr(public_api, name)
    if inspect.isclass(obj):
        signature = inspect.signature(obj)
        return f"{name}{signature}"
    if callable(obj):
        signature = inspect.signature(obj)
        return f"{name}{signature}"
    return name


def build_interface_markdown() -> str:
    public_symbols = list(public_api.__all__)
    signatures = [_format_signature(name) for name in public_symbols]
    signature_lines = "\n".join(f"- `{sig}`" for sig in signatures)

    return f"""# OpenAtoms User/Agent Interface

This document is generated by `scripts/generate_interface_report.py`.
Do not edit by hand.

## Installation

Core package:

```bash
python -m pip install openatoms
```

Optional simulator extras:

```bash
python -m pip install "openatoms[cantera]"
python -m pip install "openatoms[opentrons]"
python -m pip install "openatoms[mujoco]"
python -m pip install "openatoms[all]"
```

## Minimal Public-API Example

```python
from openatoms import (
    Container,
    Matter,
    Move,
    Phase,
    Q_,
    build_protocol,
    compile_protocol,
    create_protocol_state,
    protocol_hash,
    run_dry_run,
    validate_protocol_ir,
)

source = Container(
    id="A1",
    label="A1",
    max_volume=Q_(300, "microliter"),
    max_temp=Q_(80, "degC"),
    min_temp=Q_(4, "degC"),
)
destination = Container(
    id="A2",
    label="A2",
    max_volume=Q_(300, "microliter"),
    max_temp=Q_(80, "degC"),
    min_temp=Q_(4, "degC"),
)
source.contents.append(
    Matter(
        name="water",
        phase=Phase.LIQUID,
        mass=Q_(100, "milligram"),
        volume=Q_(100, "microliter"),
    )
)

state = create_protocol_state([source, destination])
protocol = build_protocol("demo", [Move(source, destination, Q_(50, "microliter"))], state=state)
run_dry_run(protocol)
payload = compile_protocol(protocol)
validate_protocol_ir(payload)
print(protocol_hash(payload))
```

## Stable Public API

{signature_lines}

## Expected Errors and Handling

- `openatoms.ir.IRValidationError`:
  - Raised when IR schema or invariant validation fails.
  - Handle by catching `IRValidationError` and branching on `.code`.
- `openatoms.errors.PhysicsError` subclasses:
  - Raised by dry-run constraints (volume, thermal, mass, ordering, reaction).
  - Handle by inspecting `error_code`, `constraint_type`, and `remediation_hint`.
- `openatoms.errors.SimulationDependencyError`:
  - Raised internally when optional simulator dependencies are missing.
  - Public `invoke_optional_simulator` converts these to a `SimulatorInvocation(status="skipped")`.

## Simulator Optionality Rules

- `invoke_optional_simulator(..., simulator="opentrons")`:
  - Always runs deterministic analytical checks.
  - If `opentrons` package is missing, OpenAtoms skips direct
    `opentrons.simulate` calls but still returns analytical results.
- `invoke_optional_simulator(..., simulator="cantera")`:
  - Requires `openatoms[cantera]`.
  - Missing dependency returns `status="skipped"` with installation hint.
- `invoke_optional_simulator(..., simulator="mujoco")`:
  - Requires `openatoms[mujoco]`.
  - Missing dependency returns `status="skipped"` with installation hint.

## Determinism Contract

- `serialize_ir` uses canonical JSON (sorted keys, compact separators).
- `protocol_hash` returns SHA-256 of the canonical payload.
- Equal inputs must produce identical IR JSON and identical hash.
"""


def main() -> None:
    OUTPUT.write_text(build_interface_markdown(), encoding="utf-8")
    print(f"Wrote {OUTPUT}")


if __name__ == "__main__":
    main()
